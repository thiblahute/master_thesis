\chapter{Analyse des opportunités des technologies libres dans le
domaine de l'édition vidéo et prévisions}

\minitoc \newpage

\paragraph{}

Maintenant que les besoins et que les solutions existantes ont été
analysées on rendra compte de la situation actuelle des technologies
libres et de leurs communautés. Il est aussi important de chercher
les raisons qui expliquent que ces logiciels ne sont pas plus utilisés
par les professionnels. Puis, nous essayerons d'envisager les solutions
possibles qui permettraient de remédier à cette situation.

\paragraph{}

Dans cette partie, nous analyserons la différence entre les manières
d'envisager la création de logiciel et nous verrons quels sont les
avantages et inconvénients de ces fonctionnements. Par la suite nous
nous concentrerons sur les frameworks existants pour faire une analyse
technique de ces technologies. Puis, nous analyserons les communautés
qui portent ces différents projets afin %de déterminer les points forts et les points faibles
 de chacun des projets.  Pour finir, nous tirerons les
conclusions de cette analyse afin de trouver des solutions aux défis
qu'est la création d'un logiciel libre de montage vidéo.

\newpage

\section {Etat actuel de l'offre de logiciel libre}

Le schéma suivant permet de résumer facilement la situation:

\begin{figure} [h]
  \begin{center}
    \includegraphics[width=0.9\textwidth]{images/open-source-video-editor-timeline}
  \end{center} \caption{Open source video editors timeline (Auteur:
  Jean-François Fortin, PiTiVi designer)} \label{Yes}
\end{figure}

\paragraph{ }

On constate donc que de nombreux projets de logiciel libre de montage
vidéo on vu le jours ces 10 dernières années% et dont les objectifs sont différents
.  On peut distinguer deux types de public visés par ces projets:

\begin {itemize}

  \item {Les amateurs}

  \item {Les professionnels ou semi-professionnels}
\end {itemize}

\paragraph {Les amateurs de montages vidéo}

\subparagraph{}

Plusieurs projets libres permettent ou visent à répondre aux besoins
des amateurs, mais à l'heure actuelle %ils ne sont que partiellment adaptés à ces besoins.
. Parmi les logiciels dont l'objectif est de permettre de créer des montages
simples on distingue:

\begin {itemize}

  \item {openshot: Logiciel présentant  de nombreuses fonctionnalités,
  mais dont la
    qualité d'implémentation présente des faiblesses.}

  \item {kino: Logiciel avec un nombre de fonctionnalités limité
  permettant de faire des
    petit montages %avec efficacité.}

  \item {Vidiot qui vise la production de vidéo amateur simple}

\end {itemize}

\paragraph {}

Mais %il existe des logiciels ayant pour objectif de %répondre aux besoins plus
avancés en particulier à ceux des professionnels (précédemment
présenté dans le cadre de la définition des plus grands acteurs du
marché) % qui peuvent être utilisés dans le cadre de montage amateur. 
%Leur utilisation (et c'est plus particulièrement le cas du logiciel Cinelerra)
%demeure complexe.

\paragraph{}

Un nouveau projet a aussi récemment vu le jour, dont la finalité est
assez différente des logiciels actuellement présents. Il s'agit de
Novacut, qui permet aux créateurs de films et séries web de faire le
montage de manière collaborative %avec Internet en partageant
les ressources (footage).

\paragraph{}

% Human readable version:

% Le fait que Cinelerra ne soit packagé dans aucune distribution

% Linux montre que même ce logiciel est le seul à avoir réussi à

% prendre une part de marché dans le milieu de l'édition

% professionnelle, celui-ci n'a pas réussi à rassembler les

% développeurs et utilisateurs standard de logiciel libre.

Le fait que Cinelerra ne soit packagé \footnote{Packagé: fait
que qu'un paquet, une archive (fichier compressé) comprenant les
fichiers informatiques, les informations et procédures nécessaires
à l'installation d'un logiciel sur un système d'exploitation au sein
d'un agrégat logiciel, en s'assurant de la cohérence fonctionnelle
du système ainsi modifié ait été créé. Source: Wikipedia} dans
aucune distribution Linux \footnote {Une distribution Linux, appelée
aussi distribution GNU/Linux pour faire référence aux logiciels du
projet GNU, est un ensemble cohérent de logiciels, la plupart étant
logiciels libres, assemblés autour du noyau Linux. Source: Wikipedia}.
montre que même ce logiciel est le seul à avoir réussi à prendre une
part de marché dans le milieu de l'édition professionnel, celui-ci n'a
pas réussi à rassembler les développeurs et utilisateurs standard de
logiciel libre.

\paragraph{}

En définitive aucun projet n'a encore réussi à s'imposer et ainsi
regrouper les développeurs au sein de projets majeurs. Dans d'autre
domaines, cela a été le cas, par exemple dans le domaine des lecteurs
vidéo, Vlc a su surpasser ses concurrents, et ainsi supplanter le
marché des lecteurs vidéo, qu'il soit libre ou non. Dans le domaine
des environnements de Bureau graphique, KDE et Gnome sont arrivés à un
stade où leur supériorité technique, et en terme de fonctionnalités,
fait d'eux des plateformes de référence.

\paragraph{}

Il est donc intéressant de se demander quelles technologies et quels
logiciel(s), pourraient se voir attribuer cette place dans le monde
de l'édition vidéo libre. Nous allons donc analyser les logiciels et
les technologies libres les plus avancés, (précédemment mentionnés
dans le cadre de l'analyse de marché: Cinelerra, Kdenlive et PiTiVi).
Nous verrons ainsi s'ils ont le potentiel de pouvoir un jour rivaliser
avec les logiciels propriétaires sur le marché très fermé du montage
vidéo professionnel.

\paragraph{}

NB: Il aurait été intéressant d'analyser le logiciel lightworks,
en voie de libération, mais à l'heure actuelle, aucun code n'a été
libéré, et par conséquent, celui-ci ne peut pas faire partie de
cette analyse.

\newpage

\section{Technologies}

\paragraph{}

Pour faire une analyse technique des produits permettant de faire
de l'édition vidéo, il est nécessaire d'analyser le ``core'' des
logiciels, c'est à dire la partie du logiciel où les opérations
d'édition sont effectivement réalisées. Dans ces domaines, il existe
deux façon de procéder:

\begin{itemize} \setlength{\itemsep}{2mm}

  \item{Création d'un logiciel monolithique\index{monolithique}}

  \item{Création d'un framework \glossary {name={framework},
   description={Un framework est un ensemble d'outils et de composants
   logiciels organisés conformément à un plan d'architecture et des
   designs patterns (un patron de conception, motif de conception ou
   modèle de conception est un concept de génie logiciel destiné à
   résoudre les problèmes récurrents suivant le paradigme objet.)}}
   \index{framework}}

\end{itemize}

\subsection {Technologies monolithiques\index{monolithique} VS
technologies modulaires, frameworks}


\subsubsection{Logiciels monolithiques \index{monolithique}} %FIXME Look
                                                             %for a def

\paragraph{}

Le conception monolithique \index{monolithique} dans le cadre des
logiciels d'édition vidéo, consiste à développer au sein d'un même
entité de code:

\begin{itemize} \setlength{\itemsep}{2mm}

  \item {la partie graphique et la partie de calculs
    permettant la gestion de tout ce que l'édition non linéaire
    implique}

  \item {L'interface utilisateur.}

\end {itemize}

\paragraph{}

Par le terme logiciel monolithique\index{monolithique}, il faut réaliser
que le logiciel peut utiliser des librairies externes, mais le core de
ce même logiciel, et la logique d'édition linéaire à proprement
parler sont directement %élaborés à l'intérieur du logiciel et non par
une librairie ou framework \index{framework} externe. Cela a pour
principal avantage de présenter une conception simplifiée pour les
raisons suivantes:

\paragraph{}

Les logiciels professionnels (commerciaux) utilisent très probablement
tous ce mode de fonctionnement (même si %vraisemblablement, en interne il ont
un core qui ressemble fortement à un framework \index{framework}).Dans
le monde des logiciels libres,les développeurs de Cinelerra ont décidé
d'utiliser ce mode de fonctionnement.

On peut voir plusieurs conséquences immédiates de ce mode de
développement:

\begin{itemize} \setlength{\itemsep}{2mm}

  \item {Les développeurs n'ont pas la nécessité de penser
    en terme d'interface publique de programmation (API\index{API}), et
    n'ont pas à garantir la stabilité de celle-ci: le risque réside
    dans le fait que la qualité de l'architecture ne soit pas optimale
    car la création d'API\index{API} oblige les développeurs/architectes
    à réellement analyser les besoins de manière plus large dès
    le début de la conception. Dans le cas où l'on ne crée pas
    d'interface publique de programmation vouée à être réutilisée,
    le risque est que le travail de design et d'architecture ne soit
    pas réalisé, et que le code grandisse de manière anarchique avec
    les différents développeurs qui font des extensions au fur et à
    mesure de leurs besoins.}

  \item {Les développeurs n'ont besoin de penser l'architecture seulement
  pour les cas d'utilisation qui sont liés à ce même logiciel:
    ils n'ont pas à voir au delà de ces use cases.}

  \item {Les erreurs en terme de design n'ont pas d'incidences aussi
    graves que dans le cas d'un framework\index{framework}.}
\end {itemize}

\paragraph{}

On se rend compte que cette manière de faire a pour principal avantage
le fait que le logiciel peut être développé plus rapidement puisque
le core du logiciel, et donc le code qui implémente la logique de
l'édition non linéaire, est conçue avec pour seul cas d'utilisation,
celui du logiciel. Cependant, de nombreux inconvénients existent à
cause de la nature monolithique\index{monolithique} du design:

\subparagraph{Besoins en main d'oeuvre considérables:}

\subparagraph { }

Dans le cadre de logiciel d'édition vidéo, le code à produire est
considérable, comme le montre les statistiques (Annexes 2). Le logiciel
Cinelerra à lui seul fait plus d'un million de lignes. Une telle
quantité %(je dirai plutôt "un tel volume")de code est difficile à maintenir et requiert des ressources
importantes en terme de main d'oeuvre. Le fait que le logiciel soit
monolithique\index{monolithique} implique que celui-ci va être utilisé
seulement par ce logiciel, et par conséquent, les développeurs ne
peuvent pas compter sur d'autre utilisation de ce code pour améliorer
et développer le core du logiciel.

\paragraph{Réutilisabilité:}

\subparagraph { }

L'un des inconvénients de cette manière de faire est que le code %présent
 à l'intérieur du logiciel n'est pas réutilisable directement
par d'autres projets. %On le considère comme
``individualiste``, %situation qu'il convient d'éviter dans le cadre du
développement de logiciel libre afin de ne pas multiplier les efforts,
et dupliquer le code.

\paragraph{}

Cette façon de faire a été utilisée par le projet Cinelerra. Ce
logiciel est le plus avancé en terme de fonctionnalités %dans l'offre 
des logiciels libres de montage . On peut penser que son
architecture monolithique\index{monolithique} explique ce développement
plus abouti, bien qu'il y ait évidemment de nombreux autres facteurs qui
interviennent, en particulier le fait que ce logiciel ait été développé
par la société Heroine Virtual.

\subsubsection {Utilisation de  frameworks \index{framework}}

\paragraph{}

L'autre possibilité est de séparer en deux parties bien distinctes
l'implémentation de la logique de l'édition, lecture, encoding vidéo
(core logiciel), de la partie graphique, interaction avec l'utilisateur
final.

\paragraph {Le framework}

\subparagraph{}

La grande différence entre la conception monolithiques
\index{monolithique} et la création d'un framework \index{framework}
réside dans le le fait que dans le cadre d'un framework, on développe
une API \index{API} autour du core du logiciel. Cela résulte dans le
fait que le core est un programme (librairie) externe, réutilisable par
n'importe quel autre application.  On peut considérer que les avantages
des frameworks sont les inconvénients des applications monolithiques
\index{monolithique} et vice-versa. L'avantage principal des frameworks
sur une conception monolithique\index{monolithique} est la possibilité
de partager un même code à travers de multiples applications. Celà
permet de réunir les efforts au travers, dans notre cas précis, de
tout type d'application multimedia.

\subparagraph{}

Dans le cadre de l'édition vidéo, on peut encore distinguer deux
manière d'envisager son développement:

\begin {itemize}

  \item {Utiliser un framework multimedia généraliste, et créer les
  outils nécessaire
         au montage au dessus de celui-ci} %stupid french!\ldots On top
                                           %of it?

  \item {Créer un framework spécialement orienté montage vidéo}

\end {itemize}

\subparagraph{}

Dans le monde du logiciel libre, ces deux manières d'envisager le
développement d'un framework multimedia ont été abordées par les
deux projets de framework leader sur ce segment:

\begin {itemize}

  \item {MLT qui se définit comme étant un ``Framework multimedia design
    et développé pour le brodcasting télévisé.''}

  \item {Gstreamer qui se définit comme étant un ``framework multimédia
    basé sur la notion de pipeline" ce qui lui permet de nombreux types
    d'applications multimedia tels que des lecteurs multimédia, des
    logiciels de broadcasting, des logiciels de montage vidéo\ldots''}

\end {itemize}

\subparagraph {}

Au dessus de ces frameworks, plusieurs applications (interfaces graphiques)
de montage vidéo se sont développées.

\begin {itemize}

  \item {PiTiVi: utilise le Framework multimedia GStreamer}

  \item {Kdenlive openshot utilisent le framework\index{framework}
  orienté édition et broadcasting MLT.}

\end {itemize}

\paragraph {}

Dans le cadre des Frameworks, nous nous intéresserons en particulier
à l'analyse de ceux-ci puisque les notions relatives à l'édition
vidéo, et la gestion de toute la partie multimédia est réalisée
par ceux-ci. Les logiciels d'édition ne sont à priori que de simples
interfaces graphiques basées sur ces frameworks. Dans les faits,
l'implémentation actuelle de PiTiVi n'est pas qu'un simple interface
graphique au dessus de GStreamer, mais une partie %de la
logique d'édition vidéo actuellement %réalisée dans le logiciel même.
(ceci est en train de changer et la migration \cite{PitviPortToGes}
vers gstreamer-editing-services %???\cite{PresentationOfGes}).

\newpage \section{Analyse technique}

\paragraph {}

Dans cette partie nous allons analyser les entrailles %(EST-CE UN TERME TECHNIQUE,, JE REMPLACERAI CE MOT "ENTRAILLES" PLUTÔT PAR "STRUCTURE" 
des trois logiciels
précédemment définis: Cinelerra, PiTiVi et Kdenlive.

\subsection{Cinelerra:}

Cinelerra est développé en C++ et utilise par conséquent la paradigm
objet.  Il est distribué sous licence GPL Version 2 ou plus.

\subsubsection{Documentation du code}

\subparagraph{}

Au niveau de la documentation, celle-ci est inexistante et le code
lui-même ne contient que très peu de commentaires. Il est donc très
compliqué de comprendre le fonctionnement et les relations entre ces
centaines de milliers de lignes de code. L'analyse de son fonctionnement
est par conséquent assez complexe, et il est possible que cette analyse
contienne des %imperfections.

\subsubsection {Structuration du code}

En terme de structure, le code de Cinelerra est décomposé en 3 partie:

\begin{itemize}

  \item{Lecture, rendering  audio vidéo: ce code est principalement
    contenu dans les dossiers ``quicktime'', ``thirdparty'' et
    ``libmpeg3''.}

  \item{Effets audios et vidéos: Ceux-ci sont développés comme plugins,
    et le code est donc présent de le dossier ``plugins`` }

  \item{Edition vidéo non linéaire et interface graphique: ce code est
    contenu dans un seul et unique dossier, ``cinelerra''}

  \item{Système de plugins: Aussi développé dans le dossier
  ``cinelerra``}

\end{itemize}

\paragraph{}

Cette structure semble être assez limité puisqu'il convient en théorie
de décomposer le code par petites parties, alors que dans le cadre de
Cinelerra, le dossier ``cinelerra'' contient non  moins de 1000 fichiers
et 207789 lignes de code.

\subsubsection{Lecture, rendering}

\paragraph{}

Dans le cadre de la lecture audio et video, Cinelerra fait appel à
diverses librairies:

\begin{itemize}

  \item{ffmpeg: Solution compete, cross plateforme
  d'enregistrement, lecture, conversion de flux audio et vidéo. Il
  inclue libavcodec, librairie leader dans le domaines des
  coder/decoder\glossary{name={codec}, description={Un codec est un
  procédé
capable de compresser et/ou de décompresser un signal numérique. Ce
procédé peut être un circuit imprimé ou un logiciel.}}\index{codec}.
Il s'agit du core de la
  lecture audio et vidéo de Cinelerra.}

  \item{faac/faad: AAC audio encoder/decoder}

  \item{x264: h264 encoder}

  \item{libdv: DV codec}

  \item{\ldots}

\end{itemize}

\subparagraph{}

Toutes ces librairies sont utilisées dans le but de lire et écrire des
fichiers multimedia. Afin de standardiser, et permettre l'utilisation de
ces libraries de manière similaire au sein du logiciel, les développeurs
de Cinelerra ont élaboré au cas par cas des ponts entre ces librairies
et le reste du logiciel (Fichier dans le dossier quicktime).

\subparagraph{}

% humaine readable

%De plus, les créateurs de Cinelerra ont développé des librairies de

%codec\index{codec}, muxer et demuxer (En

%particulier Mpeg et quicktime) afin d'ameliorer l'utilisation de ces

%formats dans le cadre de l'édition vidéo. Cela a tout de même été

%effectué dans de librairies externes réutilisables par d'autres projets:

\begin{itemize}

% Human readable:

% Quicktime 4 Linux: supporte en particulier les formats DV,

% les codecs H.264 et AAC, et implémente des éléments de conversion

% d'espaces colorimétriques (colorspace conversion)

  \item {Quicktime 4 Linux: supporte en particulier les formats DV,
    les codecs H.264 et AAC, et implémente des éléments de conversion
    d'espaces colorimétriques (colorspace conversion)}

% Human readable

% Libmepg3: supporte la plupart des formats du ``Mpeg Picture

% Motion Group''  et permet l'édition vidéo en utilisant ces

% formats bien qu'il ne soit pas conçu pour ce type d'utilisation.

  \item {Libmepg3: supporte la plupart des formats du ``Mpeg Picture
    Motion Group'' \glossary{name={mpeg}, description={MPEG, sigle de
    Moving Picture Experts Group, est le groupe de travail SC 29/WG 11
    du comité technique mixte JTC 1 de l’ISO et de la CEI pour les
    technologies de l’information. Ce groupe d’experts est chargé
    du développement de normes internationales pour la compression, la
    décompression, le traitement et le codage de la vidéo, de l’audio
    et de leur combinaison, de façon à satisfaire une large gamme
    d’applications. Source: Wikipedia}} et permet l'édition vidéo en
    utilisant ces formats bien qu'il ne soit pas conçu pour ce %type d'utilisation.}

\end{itemize}

\subsubsection {Effets audio et vidéo}

Afin de permettre la création d'effets, Cinelerra utilise du  code
provenant de deux librairies:

\begin{itemize}

  \item {ladspa, Linux Audio Developers Simple Plugins API: Librairie
  d'effets audios qui contient une multitude de plugins.Il s'agit d'une
  API très simple et extrêmement flexible qui théoriquement permet
  la création de plugins permettant n'importe quelle manipulation
  et transformation du son. %Dans les faits, certaines
  fonctionnalités ne sont pas implémentées pour éviter de complexifier
  le core de la librairies.}

  \item {frei0r: Framework minimalist multi-platform de création
    d'effets vidéo. Il permet la création d'effets à travers des
    plugins. Il s'agit du standard de fait en terme d'effets vidéo
    dans le milieu des logiciels libres. Cette librairie a été
    %élaborée par de nombreux développeurs issus de différentes
    communautés de logiciels libres en relation avec le multimedia. De
    nombreux plugins existent et sont stables, mais %ils présentent un inconvénient
    assez important existe concernant ce set d'effet %car ils
    supportent uniquement l'espace de couleur RGB. Cela a pour
    conséquence que dans le cas ou le flux vidéo n'est pas dans
    cette espace de couleur,%CE N'EST PAS CLAIR COMME EXPLICATION\glossary {name={espace colorimétrique}
    description={Un espace colorimétrique ou espace de couleur associe
    des nombres aux couleurs visibles.  Compte tenu des limites de
    la vision humaine, ces nombres se présentent généralement sous
    la forme de triplets. Chaque couleur de lumière peut donc être
    caractérisée par un point dans un espace à trois dimensions. Lors
    d'une impression, pour des raisons liées à la qualité des
    pigments, l'espace utilisé comporte alors généralement au moins
    quatre dimensions. Source: Wikipedia}} une conversion d'espace
    colorimétrique est nécessaire afin de les utiliser. Un autre
    inconvénient de cette librairie %réside dans le fait que les effets sont réalisés de
    manière logicielle, alors qu'à l'heure actuelle, l'utilisation de la
    carte graphique permettrait de tirer partie de manière beaucoup
    plus intéressante dans l'application d'effets sur
    les vidéos.}

%SAMEDI SOIR


\end{itemize}

\paragraph{}

Afin de permettre l'utilisation d'effets, les développeurs de Cinelerra
on mis en place un système de plugins. En terme d'implémentation,
Cinelerra reprend le code de ces librairie dans un set de plugins
Cinelerra en ajoutant l'implémentation de l'interface graphique qui
permet la configuration de ces effets.

\subsubsection{Interface Graphique}

\paragraph{}

L'interface graphique est développé en utilisant directement le server
X sans aucune librairie graphique au dessus. Celà a pour conséquence
d augmenté le code à produire mais permet de controller complètement
le projet sans dépendre de ces librairies.  Dans le cadre de Cinelerra,
cela est sensé puisque ce logiciel est développé quasi intégralement
en interne.

\begin{figure} [H]

  \begin{center}

    \includegraphics[width=0.95\textwidth]{images/cinelerra}

  \end{center}

  \caption{Interface graphique de cinelerra}

  \label{Yes}

\end{figure}

\paragraph{Structure de l'interface graphique:}

L'interface graphique de cinelerra est composé de quatre fenêtres
principales:

\begin{itemize}
  \item {La timeline (en bas à gauche sur le screenshot): cette
    partie permet de gérer un grand nombre d'action sur le contenu de
    la timeline.}

  \item {La fenêtre de ressource (un bas à droite sur le screenshot):
    dans, cette fenêtre, l'utilisateur peu accéder au différent
    footage qu'il a importer, il peut aussi accéder au différent effets,
    transitions\ldots}

  \item {Le fenêtre de preview (en haut à gauche sur le screenshot):
    cette fenêtre permet la prévisualisation des footage avant de les
    importer dans la timeline}

  \item {La fenêtre de composition (en haut à droite sur le screenshot):
    cette fenêtre permet d'effectuer des operation sur les vidéo et
    de prévisualiser la timeline.}

\end{itemize}

\subsubsection{Edition non linéaire}

\paragraph{Conception}

\subparagraph{}

Dans Cinelerra, l'interface utilisateur et la logique de l'édition
vidéo sont deux partie complètement interdépendante. Au sein du
code, il n'est pas possible de savoir quel partie est plutôt liée à
l'interface graphique et quel partie fait les calculs. Celà est due au
fait de sa conception monolithique, les développeurs n'ont pas pris la
peine de dissocier ces deux parties qui sont conceptuelement complètement
différente. On s'aperçoit en lisant le code que

\paragraph{Acceleration materiel}

\subparagraph{}

Lorsque openGL\index{openGL} est présent sur le système, Cinelerra
est en mesure de l'utiliser directement, dans la mesure où cette
fonctionnalité ai été activé lors de la compilation. Celà à pour
effet d'accélérer, principalement la fonction de compositing, mais
aussi la gestion des effets vidéo openGL.

%TODO %\paragraph{Fonctionnalités}

%\subparagraph{}

%En terme de fonctionnalité, le logiciel cinelerra permet de répondre

%de très nombreux besoins des professionnel.

\subsection {Kdenlive}

Comme précédemment énoncé, Kdenlive utilise le framework orienté
montage et broadcasting MLT. Dans cette partit, nous allons dans un
premier temps analyser ce framework.

\subsubsection {Framework multimedia orienté montage: MLT}

\paragraph {Panorama de la technologie} %Overview?

\subparagraph{}

Le framework MLT est écrit en C et offre une API\index{API} stable
simple et minimalist. Il n'est basé sur aucun library (seulement POSIX

\glossary {name={POSIX}, description={POSIX est le nom d'une famille
de standards définie depuis 1988 par l'Institute of Electrical and
Electronics Engineers et formellement désignée IEEE 1003. Ces standards
ont émergé d'un projet de standardisation des API des logiciels
destinés à fonctionner sur des variantes du système d'exploitation
UNIX. Il s'agit de la standardisation des API des système communément
appelé UNIX. Source: Wikipedia}} et le standard C, C99). MLT bien
qu'écrit en C, utilise le paradigme de la programmation orienté objet en
implémentant en intern le concept d'objet. Ce framework est modulaire,
et conçue pour permettre le développement nouveaux composants. Il
permet l'utilisation des différents core des processeur pour faire
les calculs, afin d'utiliser au mieux les processeur modernes. Il est
aussi cross platform et peu être utilisé sur les principaux système
d'exploitation: Linux, BSD, OS X et windows.

\subparagraph{}

MLT est distribué sous licence LGPL Version

\paragraph{Concepts de base}

\subparagraph{Réseau de service}

\subparagraph{}

Le framework MLT est basé sur le concept de de réseau de service sur
lequel on distingue trois entité (classes) clés: producteur, filtre
et consommateur. Ces différentes classes sont toutes des sous classe
de la classe appelé ``service``.

On peu schématiser le concept de réseau de service le plus simple de
la manière suivante:

\begin{figure} [H]

  \begin{center}

    \includegraphics[width=0.95\textwidth]{images/producerConsumer}

  \end{center}

  \caption{Schéma du concept de producteur, filtre, consomateur}

  \label{Yes}

\end{figure}

Le producteur a pour rôle de produire des données (lire un fichier
audio, vidéo\ldots) et de les faire passer au consommateur qui lui est
connecté. Le consommateur a pour but de faire passer ces donné (output
datas) à la carte son, device vidéo, un autre fichier, où retransmettre
à travers d'un moyen de télécommunication (broadcasting).  Le filtre
qui n'est pas obligatoire afin de lire des donnés multimedias, permet
de modifier les donnés (par exemple produisant un effet vidéo/audio),
il peu aussi être connecté à plusieurs producteur, par exemple afin
de produire une transition entre ceux-ci.

\subparagraph{}

Mais cela ne permet pas la creation d'éditeur de vidéo non linéaire,
mais seulement la lecture et création de fichier. Pour permettre cette
fonctionnalité, la classe multitrack a étés mise en place. Celle-ci
permet de gérer plusieurs producteurs et filtres les uns à la suite des
autres. La multitrack contient plusieurs producteurs et les dispose les
hein à la suite des autres. Ces même producer peuvent aussi provenir
d'une playlist qui est un concept différent, et celles-ci peuvent aussi
être ajouter directement à un multitrack, et enregistrer sous forme
de fichier de playlist (dans les différents standards existants).

\subparagraph{}

Grace à la création de ces réseau de service, il est possible de
créer des timelines complexe, et ainsi créer des logiciel d'édition
vidéo non linéaire. On peu donc schématiser les réseaux de services
de la manière suivante:

\begin{figure} [H]

  \begin{center}

    \includegraphics[width=1.0\textwidth]{images/service}

  \end{center}

  \caption{Schéma simplifié d'un service MLT (point de vu intern et
    non utilisateur du framework)}

  \label{Yes}

\end{figure}

\paragraph{Les modules}

\subparagraph{}

Dans MLT, les de producteur, consommateurs où filtres sont des classes
extern implémenté sous form de plugins. Certain sont implémenté
directement dans MLT tel que :

\begin{itemize}

  \item {Le filtre ``transition'': permet la création de transition}

  \item {Le filtre mono: permet de convertir un flux audio en mono}

  \item {Le filtre resize: Permet de redimensionner une vidéo}

  \item {\ldots}

\end{itemize}

Cela est fait grace à des libraries extern en implémentant des modules
externes afin de faire le lien (wrapper)

\glossary{name={adapter}, description={Il permet de convertir l'interface
d'une classe en une autre interface que le client attend. L' Adaptateur
fait fonctionner ensemble des classes qui n'auraient pas pu fonctionner
sans lui, à cause d'une incompatibilité d'interfaces. Source:
Wikipedia}}

entre ces librairie et l'API\index{API} précédemment présenté. Les
principales libraries actuellement utilisables à travers de ce framework
sont:

\begin{itemize}

  \item {libav, libdv et libvorbis pour ce qui en ai des codecs et
  muxers/demuxers}

  \item {frei0r pour les effets vidéos}

  \item {ladspa pour les effets audios}

  \item {\ldots}

\end{itemize}

\subparagraph{}

Ces différents services disponibles permette de lire un nombre
considérable de vidéo, en particulier grace à libav, et d'effectuer
de très nombreuses operation principalement grace aux plugins frei0r
pour la vidéo et ladspa pour ce qui concerne l'audio.

\paragraph{Gestion des services}

\subparagraph{Le ``repository``}

Afin de permettre à l'utilisateur de connaitre les différent services
présents sur le système, il existe une classe Repository. Celle-ci
offre une API\index{API} simple listant les différent service par type
(consommateurs, producteur où filtre),  par example, le simple code
suivant, permet de récupérer la liste de touts les effets présent
sur le système:

\subparagraph{}

\begin{lstlisting}
  mlt_repository repo = mlt_repository_init (NULL) /* We just use the
  standard module path */ mlt_properties filters = mlt_repository_filters
  (repo); /*
\end{lstlisting}

\subparagraph{Les ``factory''}

Afin de permettre de simplifier la création de services de différents
types, MLT utilise le design pattern de la factory. Cela permet de
créer n'importe quel type de service de manière simple en utilisant les
différentes factories existante. Bien que tout les objets d'un réseau
de service soient des descendant de la classe Service, les développeur
ont décidé de créer 4 méthode différente de la classe factory:

\begin{itemize}

  \item {mlt\_factory\_producer: permet d'instancier des producteurs}

  \item {mlt\_factory\_filter: permet d'instancier des filtres}

  \item {mlt\_factory\_transition: permet d'instancier des transitions}

  \item {mlt\_factory\_consumer: permet d'instancier des consommateurs}

\end{itemize}

\subparagraph{}

Par exemple, afin de créer un effet ``invert'' depuis MLT il suffi
de faire:

\subparagraph{}

\begin{lstlisting}
  filter = mlt_factory_filter ( "invert", "my-invert-effect");
\end{lstlisting}

Il sera ensuite possible d'ajouter ce service au réseau de service.

\subparagraph{Les données dans un réseau de services}

\subparagraph{La classe Frame}

\subparagraph{}

Les données qui transite dans un réseau de service sont contenus dans
des objets de type frame. Celles-ci contiennent à la fois les donnés
audio et les donnés vidéos. Les producteurs peuvent setter ces données
grace aux méthodes mlt\_frame\_set\_audio et mlt\_frame\_set\_video.

\subparagraph{Relation entre les différents services en terme de flux
de données}

Afin commencer le flux de données dans un réseau de service, le
consommateur est celui qui tire les données depuis le service sur
lequel il est connecté.  Les autre services réagissent en fonction,
et forme une chaine jusqu'au producteur qui produits les données, et
les fait suivre aux service suivant et ainsi de suite. Ce processus peu
être schématisé de la manière suivante:

\begin{center}

  \begin{tabular}{ | c | c | c | c |}

    \hline

      Phase & producteur              & Filtre                      &
      Consommateur    \\ \hline \hline

      1     &                         &                             &
      Request frame   \\ \hline 2     &                         &
      Réception de la demande     &                 \\
            &                         & Demande la frame à son tour&
            \\ \hline
      3     & Réception de la demande &                             & \\
            & Génération de la frame à la position &                &
            \\ & Mise à jours de la position          &                &
            \\ & Mise à disposition de la frame       &                &
            \\ \hline
      4     &                         & Réception de la frame       & \\
            &                         & Update de la frame          & \\ &
            & Mise à disposition          & \\ \hline
      5     &                         &                             &
      Réception et    \\
            &                         &                             &
            process de      \\ &                         & & la
            frame        \\

    \hline

  \end{tabular}

\end{center}

\subparagraph{}

Cette manière de fonctionner implique que seul le consommateur est
le moteur du réseau, il est celui qui doit faire partit d'un thread
séparé et les appel à la fonction get\_frame doivent être fait dans
une boucle principal.  Ces appels s'arrêteront au moment ou le flux a
été terminé (EOS).


\paragraph{Acceleration materiel}

\subparagraph{}

Au niveau de l'accélération materiel, MLT supporte le decoding
avec acceleration materiel pour les cartes graphiques Nvidia
\glossary{name={Nvidia}, description={Nvidia Corporation est l'un des plus
grands fournisseurs de processeurs graphiques, de cartes graphiques et de
chipsets pour PC et consoles de jeux}} (via VDPAU), et pour l'affichage
mais pas le compositing vidéo accéléré.

\glossary{name={VDPAU}, description={VDPAU (Video Decode and Presentation
API for Unix) est une bibliothèque open source (libvdpau) et une
interface de programmation conçus par NVIDIA initialement pour ses
cartes graphiques GeForce 8 et ses derniers processeurs graphiques. Cette
interface permet à des programmes de vidéo de décharger de la mémoire
des parties du processus de décodage de vidéo et de son traitement
aval vers le processeur graphique.}}

\paragraph{Fonctionnalités haut niveau (High level features)}

\subparagraph{}

La petit API qu'offre ce framework comporte des méthode et fonction
haut niveau et permettent de répondre à des besoins spécifiques de
l'édition vidéo de manière simple pour l'utilisateur.

\subparagraph{Génération de waveform/thumbnail depuis une frame}

\subparagraph{}

Le framework offre par example une fonction permettant la génération
(sous forme d'image) des waveform de la partie audio d'une frame, et de
thumbnail depuis la partier audio.  Dans la partie précédente, nous
avons constaté que la visualisation avancé de chaque frame était une
fonctionnalité très utile en particulier dans le cadre de la création
de films.

\subparagraph{Serialization et deserialization de projets}

\subparagraph{}

Il intègre un système de serialisation, deserialization, ce qui permet
de sauvegarder facilement les projets, avec les différents tracks,
effets, transition\ldots dans le cadre d'application de montage vidéo.

\subparagraph{}

Le framework MLT offre des bindings haut niveau pour les languages:
C++, C\#, Java, Lua, Perl, PHP, Ruby, TCL et Python. Celà permet à
beaucoup plus de développeur d'envisager l'utilisation de MLT dans
leurs applications. C'est grosse au binding C++ que Kdenlive à pu être
développé au dessus du framework\index{framework} MLT

\paragraph{Fonctionnalités}

\subparagraph{ }

Cette analyse technique du projet MLT nous permet de constater que
son fonctionnement est simple, et son API petite, et facile à prendre
en main.  Il permet de répondre à différents besoins de base  des
professionnels en terme de fonctionnalités:

\begin{itemize}

  \item {Ajout de titres et génériques: A travers du module développé
  par la
    communauté Kdenlive: QImage.}

  \item {Gestion des keyframes: possible dans les modules implémentant
    cette fonctionnalités, pas de solution générique au niveau du
    core de MLT}

  \item {Visualization image par images et waveform: Directement
  accessible à
    travers du core de MLT.}

  \item {Visualization image par images et waveform: Directement
  accessible à
    travers du core de MLT.}

\end{itemize}

\subparagraph{}

Le principale manque en terme de fonctionnalité est la possibilité de
faire du time remapping, mais il est tout de même possible de gérer le
control de la vitesse de lecture des clips, ce qui est un point essentiel.

\subsubsection {Logiciel de montage vidéo basé sur MLT: Kdenlive}

\subparagraph{}

Kdenlive est l'éditeur vidéo créé par la communauté en charge
du bureau libre KDE. Ce logiciel est donc écrit en C++ utilisant le
framework graphique QT \glossary{name={QT}, description={framework
orienté objet et développé en C++ par Qt Development Frameworks,
filiale de Nokia. Il offre des composants d'interface graphique (widgets),
d'accès aux données, de connexions réseaux, de gestion des fils
d'exécution, d'analyse XML, etc. Qt est par certains aspects un framework
lorsqu'on l'utilise pour concevoir des interfaces graphiques ou que l'on
architecture son application en utilisant les mécanismes des signaux
et slots par exemple.}} ainsi que les kdelibs qui forment le framework
permettant la création d'application intégré au bureaux du même nom.
L'analyse technique de ce logiciel n'a pas vraiment d'intérêt,
s'agissant d'une interface graphique tirant partit du framework MLT.

\paragraph {Interface Graphique}

\subparagraph{}

Il conviendra tout de monde de presenter succintement cette interface,
pour ce voici un screenshot:

\subparagraph{}

\begin{figure}[H]

  \begin{center}

    \includegraphics[width=0.90\textwidth]{images/kdenlive}

  \end{center}

  \caption{Screenshot de Kdenlive}

  \label{Yes}

\end{figure}

L'interface graphique de Kdenlive est composé d'une seule fenetre et
decomposer en quatre elements majeurs:

\begin{itemize}

  \item {La timeline en bas}

  \item {La gestion des footage, en haut à gauche}

  \item {La gestion des effets et transitions, au centre en haut. La
  configuration de ceux-ci ce fait dans cette même partie.}

  \item {Le previewer, en haut à droite}

\end{itemize}

\subsection {PiTiVi}

Comme précédemment énoncé, PiTiVi utilise le framework multimedia
GStreamer. Dans cette partie, nous nous concentrerons sûre l'analyse
de ce framework.

\subsubsection {Framework multimedia: GStreamer}

\paragraph {Panorama de la technologie} %Overview?

\subparagraph{}

Le framework GStreamer est aussi écrit en C. Base sur le concept du
pipeline, concept assez similaire a ce que sont les réseaux de
service, c'est a dire que les données transit d'un element (equivalent
a un service dans MLT) a un autre afin d'obtenir le résultat dans le
dernier element de la chaine. L' API de ce framework est plus complete que celle de
MLT puisque les use-cases auxquels celui- ci cherche a répondre sont plus
nombreux. Ce framework, bien qu'écrit en C, utilise le paradigme objet,
a travers de la librairie Glib. Cette librairie implémente de nombreuse
nombreuse API et en particulier la notion d'objet en C a travers du
module GObject.  Cette librairie permet aussi la gestion des thread, des
signaux\ldots De très nombreux projets de logiciel libre l'utilisent,
en particulier le projet d'interface graphique Gnome. GStreamer offre
une API stable aussi bien pour les développeur de plugins que pour les
développeurs d'applications. Il est hautement multi threaded, et est
thread safe.

et offre en core assez petit a partir duquel de nombreux plugins sont
devellope. Les plugins GStreamer sont classifie par set selon des
criteres precis:

\begin{itemize}
  \item {}
\end{itemize}


\subsection {}

\newpage \section{Analyse des communautés}

\newpage \section{Lacunes}

\newpage \section{Solutions possibles}
